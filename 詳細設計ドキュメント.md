# 画像ビューワーアプリケーション 詳細設計書

## 1. 設計の概要

本ドキュメントでは、エロ絵と健全絵を分類する機能を持つ画像ビューワーアプリケーションの詳細設計を定義する。設計アプローチとして、クリーンアーキテクチャとMVVMパターンを採用し、保守性・拡張性の高いアプリケーションを目指す。

### 1.1 アーキテクチャの全体像

本アプリケーションは以下の4つの主要レイヤーから構成される：

1. **プレゼンテーション層 (Presentation Layer)**
   - ユーザーインターフェース
   - ビューモデル
   - ユーザー入力処理

2. **アプリケーション層 (Application Layer)**
   - ユースケース実装
   - コマンド・クエリ処理
   - サービスオーケストレーション

3. **ドメイン層 (Domain Layer)**
   - エンティティ
   - ビジネスルール
   - リポジトリインターフェース

4. **インフラストラクチャ層 (Infrastructure Layer)**
   - 永続化実装
   - 外部サービス/ライブラリ連携
   - デバイスアクセス

### 1.2 レイヤー間の依存関係

依存関係の方向は外側から内側に向かう：

- プレゼンテーション層 → アプリケーション層 → ドメイン層 ← インフラストラクチャ層

この依存関係の方向性により、内側のレイヤー（特にドメイン層）は外側のレイヤーの実装詳細から独立して保たれる。

### 1.3 MVVM (Model-View-ViewModel) パターン

プレゼンテーション層はMVVMパターンを採用：

- **Model**: ドメイン層とアプリケーション層のコンポーネント
- **View**: UI要素（PyQt/PySide6のウィジェット）
- **ViewModel**: ViewとModelの間を仲介し、Viewに表示するデータを加工・提供

## 2. ドメイン層 (Domain Layer)

ドメイン層はアプリケーションの中核となるビジネスロジックを含み、他のレイヤーへの依存を持たない。

### 2.1 エンティティ (Entities)

#### 2.1.1 Image

画像ファイルを表すエンティティ。

```python
class Image:
    def __init__(self, id: str, path: str, filename: str, file_type: str, 
                 size: int, width: int, height: int, created_at: datetime,
                 modified_at: datetime):
        self.id = id                # 一意のID
        self.path = path            # ファイルパス
        self.filename = filename    # ファイル名
        self.file_type = file_type  # ファイル種別 (jpg, png, gif, mp4 etc.)
        self.size = size            # ファイルサイズ (bytes)
        self.width = width          # 画像の幅
        self.height = height        # 画像の高さ
        self.created_at = created_at        # 作成日時
        self.modified_at = modified_at      # 最終更新日時
```

#### 2.1.2 ImageClassification

画像の分類結果を表すエンティティ。

```python
class ImageClassification:
    def __init__(self, id: str, image_id: str, is_nsfw: bool, 
                 nsfw_score: float, classification_method: str,
                 classified_at: datetime):
        self.id = id                          # 一意のID
        self.image_id = image_id              # 画像ID
        self.is_nsfw = is_nsfw                # NSFWフラグ
        self.nsfw_score = nsfw_score          # NSFWスコア (0-1)
        self.classification_method = classification_method  # 分類手法
        self.classified_at = classified_at    # 分類日時
```

#### 2.1.3 Tag

画像に付けられたタグを表すエンティティ。

```python
class Tag:
    def __init__(self, id: str, name: str, category: str):
        self.id = id              # 一意のID
        self.name = name          # タグ名
        self.category = category  # タグカテゴリ (character, style, content, etc.)
```

#### 2.1.4 ImageTag

画像とタグの関連を表すエンティティ。

```python
class ImageTag:
    def __init__(self, image_id: str, tag_id: str, confidence: float,
                 tagged_at: datetime):
        self.image_id = image_id      # 画像ID
        self.tag_id = tag_id          # タグID
        self.confidence = confidence  # 信頼度 (0-1)
        self.tagged_at = tagged_at    # タグ付け日時
```

#### 2.1.5 Folder

フォルダを表すエンティティ。

```python
class Folder:
    def __init__(self, id: str, path: str, name: str, parent_id: Optional[str]):
        self.id = id              # 一意のID
        self.path = path          # パス
        self.name = name          # フォルダ名
        self.parent_id = parent_id  # 親フォルダID
```

### 2.2 値オブジェクト (Value Objects)

#### 2.2.1 ImageSize

画像サイズを表す値オブジェクト。

```python
class ImageSize:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        
    def get_aspect_ratio(self) -> float:
        return self.width / self.height if self.height != 0 else 0
        
    def scale(self, factor: float) -> 'ImageSize':
        return ImageSize(int(self.width * factor), int(self.height * factor))
```

#### 2.2.2 FilePath

ファイルパスを表す値オブジェクト。

```python
class FilePath:
    def __init__(self, path: str):
        self.path = path
        
    def get_directory(self) -> str:
        return os.path.dirname(self.path)
        
    def get_filename(self) -> str:
        return os.path.basename(self.path)
        
    def get_extension(self) -> str:
        return os.path.splitext(self.path)[1].lower()
```

### 2.3 リポジトリインターフェース (Repository Interfaces)

#### 2.3.1 ImageRepository

画像エンティティのリポジトリインターフェース。

```python
class ImageRepository(ABC):
    @abstractmethod
    def get_by_id(self, image_id: str) -> Optional[Image]:
        pass
    
    @abstractmethod
    def get_by_path(self, path: str) -> Optional[Image]:
        pass
    
    @abstractmethod
    def get_images_in_folder(self, folder_path: str, 
                            page: int = 0, page_size: int = 100) -> List[Image]:
        pass
    
    @abstractmethod
    def save(self, image: Image) -> Image:
        pass
    
    @abstractmethod
    def delete(self, image_id: str) -> bool:
        pass
    
    @abstractmethod
    def search(self, query: str) -> List[Image]:
        pass
```

#### 2.3.2 ClassificationRepository

分類結果のリポジトリインターフェース。

```python
class ClassificationRepository(ABC):
    @abstractmethod
    def get_by_image_id(self, image_id: str) -> Optional[ImageClassification]:
        pass
    
    @abstractmethod
    def save(self, classification: ImageClassification) -> ImageClassification:
        pass
    
    @abstractmethod
    def get_nsfw_images(self, page: int = 0, page_size: int = 100) -> List[str]:
        pass
    
    @abstractmethod
    def get_sfw_images(self, page: int = 0, page_size: int = 100) -> List[str]:
        pass
```

#### 2.3.3 TagRepository

タグのリポジトリインターフェース。

```python
class TagRepository(ABC):
    @abstractmethod
    def get_by_id(self, tag_id: str) -> Optional[Tag]:
        pass
    
    @abstractmethod
    def get_by_name(self, name: str) -> Optional[Tag]:
        pass
    
    @abstractmethod
    def save(self, tag: Tag) -> Tag:
        pass
    
    @abstractmethod
    def get_tags_for_image(self, image_id: str) -> List[Tag]:
        pass
    
    @abstractmethod
    def add_tag_to_image(self, image_id: str, tag_id: str, 
                         confidence: float) -> bool:
        pass
    
    @abstractmethod
    def remove_tag_from_image(self, image_id: str, tag_id: str) -> bool:
        pass
```

#### 2.3.4 FolderRepository

フォルダのリポジトリインターフェース。

```python
class FolderRepository(ABC):
    @abstractmethod
    def get_by_id(self, folder_id: str) -> Optional[Folder]:
        pass
    
    @abstractmethod
    def get_by_path(self, path: str) -> Optional[Folder]:
        pass
    
    @abstractmethod
    def get_subfolders(self, parent_id: str) -> List[Folder]:
        pass
    
    @abstractmethod
    def save(self, folder: Folder) -> Folder:
        pass
```

### 2.4 ドメインサービス (Domain Services)

#### 2.4.1 ImageClassificationService

画像分類に関するドメインサービス。

```python
class ImageClassificationService:
    def classify_is_nsfw(self, image: Image, 
                        classifier_type: str = "default") -> ImageClassification:
        """画像がNSFWかどうかを分類する"""
        pass
    
    def analyze_tags(self, image: Image, 
                    tagger_type: str = "danbooru") -> List[Tuple[Tag, float]]:
        """画像のタグを分析する"""
        pass
```

## 3. アプリケーション層 (Application Layer)

アプリケーション層はドメイン層を利用してユースケースを実装する。

### 3.1 ユースケース (Use Cases)

#### 3.1.1 ViewImageUseCase

画像を表示するユースケース。

```python
class ViewImageUseCase:
    def __init__(self, image_repository: ImageRepository,
                classification_repository: ClassificationRepository,
                tag_repository: TagRepository):
        self.image_repository = image_repository
        self.classification_repository = classification_repository
        self.tag_repository = tag_repository
    
    def execute(self, image_id: str) -> Dict:
        """画像を表示するために必要な情報を取得する"""
        image = self.image_repository.get_by_id(image_id)
        if not image:
            raise ValueError(f"Image not found: {image_id}")
        
        classification = self.classification_repository.get_by_image_id(image_id)
        tags = self.tag_repository.get_tags_for_image(image_id)
        
        return {
            "image": image,
            "classification": classification,
            "tags": tags
        }
```

#### 3.1.2 BrowseFolderUseCase

フォルダ内の画像を閲覧するユースケース。

```python
class BrowseFolderUseCase:
    def __init__(self, folder_repository: FolderRepository,
                image_repository: ImageRepository):
        self.folder_repository = folder_repository
        self.image_repository = image_repository
    
    def execute(self, folder_path: str, page: int = 0, 
               page_size: int = 100) -> Dict:
        """フォルダ内の画像とサブフォルダを取得する"""
        folder = self.folder_repository.get_by_path(folder_path)
        if not folder:
            raise ValueError(f"Folder not found: {folder_path}")
        
        subfolders = self.folder_repository.get_subfolders(folder.id)
        images = self.image_repository.get_images_in_folder(
            folder_path, page, page_size
        )
        
        return {
            "folder": folder,
            "subfolders": subfolders,
            "images": images,
            "page": page,
            "page_size": page_size,
            "total_images": len(images)  # 本来は総数をリポジトリから取得
        }
```

#### 3.1.3 ClassifyImageUseCase

画像を分類するユースケース。

```python
class ClassifyImageUseCase:
    def __init__(self, image_repository: ImageRepository,
                classification_repository: ClassificationRepository,
                classification_service: ImageClassificationService):
        self.image_repository = image_repository
        self.classification_repository = classification_repository
        self.classification_service = classification_service
    
    def execute(self, image_id: str, classifier_type: str = "default") -> ImageClassification:
        """画像を分類し、結果を保存する"""
        image = self.image_repository.get_by_id(image_id)
        if not image:
            raise ValueError(f"Image not found: {image_id}")
        
        classification = self.classification_service.classify_is_nsfw(
            image, classifier_type
        )
        saved_classification = self.classification_repository.save(classification)
        
        return saved_classification
```

#### 3.1.4 TagImageUseCase

画像にタグを付けるユースケース。

```python
class TagImageUseCase:
    def __init__(self, image_repository: ImageRepository,
                tag_repository: TagRepository,
                classification_service: ImageClassificationService):
        self.image_repository = image_repository
        self.tag_repository = tag_repository
        self.classification_service = classification_service
    
    def execute(self, image_id: str, tagger_type: str = "danbooru") -> List[Dict]:
        """画像を分析してタグを付け、結果を保存する"""
        image = self.image_repository.get_by_id(image_id)
        if not image:
            raise ValueError(f"Image not found: {image_id}")
        
        tag_results = self.classification_service.analyze_tags(
            image, tagger_type
        )
        
        results = []
        for tag, confidence in tag_results:
            # タグが存在しなければ作成
            existing_tag = self.tag_repository.get_by_name(tag.name)
            if not existing_tag:
                existing_tag = self.tag_repository.save(tag)
            
            # 画像にタグを関連付け
            self.tag_repository.add_tag_to_image(
                image_id, existing_tag.id, confidence
            )
            
            results.append({
                "tag": existing_tag,
                "confidence": confidence
            })
        
        return results
```

#### 3.1.5 BatchClassifyImagesUseCase

複数画像を一括で分類するユースケース。

```python
class BatchClassifyImagesUseCase:
    def __init__(self, image_repository: ImageRepository,
                classification_repository: ClassificationRepository,
                tag_repository: TagRepository,
                classification_service: ImageClassificationService):
        self.image_repository = image_repository
        self.classification_repository = classification_repository
        self.tag_repository = tag_repository
        self.classification_service = classification_service
    
    def execute(self, folder_path: str, 
               apply_nsfw: bool = True, 
               apply_tags: bool = True) -> Dict:
        """フォルダ内の画像を一括で分類・タグ付けする"""
        images = self.image_repository.get_images_in_folder(folder_path)
        
        results = {
            "total": len(images),
            "nsfw_classified": 0,
            "tagged": 0
        }
        
        for image in images:
            if apply_nsfw:
                try:
                    classification = self.classification_service.classify_is_nsfw(image)
                    self.classification_repository.save(classification)
                    results["nsfw_classified"] += 1
                except Exception as e:
                    print(f"Error classifying image {image.id}: {e}")
            
            if apply_tags:
                try:
                    tag_results = self.classification_service.analyze_tags(image)
                    for tag, confidence in tag_results:
                        existing_tag = self.tag_repository.get_by_name(tag.name)
                        if not existing_tag:
                            existing_tag = self.tag_repository.save(tag)
                        self.tag_repository.add_tag_to_image(
                            image.id, existing_tag.id, confidence
                        )
                    results["tagged"] += 1
                except Exception as e:
                    print(f"Error tagging image {image.id}: {e}")
        
        return results
```

### 3.2 サービス (Services)

#### 3.2.1 FileSystemService

ファイルシステムとのやり取りを担当するサービス。

```python
class FileSystemService:
    def scan_directory(self, path: str) -> Dict:
        """ディレクトリをスキャンし、画像ファイルとフォルダのリストを返す"""
        pass
    
    def load_image_data(self, path: str) -> bytes:
        """画像ファイルのバイナリデータを読み込む"""
        pass
    
    def get_image_metadata(self, path: str) -> Dict:
        """画像ファイルのメタデータを取得する"""
        pass
    
    def create_thumbnail(self, image_path: str, 
                        target_path: str, size: Tuple[int, int]) -> bool:
        """画像のサムネイルを作成する"""
        pass
```

#### 3.2.2 ClassificationModelService

分類モデルを管理するサービス。

```python
class ClassificationModelService:
    def __init__(self):
        self.loaded_models = {}
    
    def load_model(self, model_type: str) -> bool:
        """指定された種類のモデルをロードする"""
        pass
    
    def unload_model(self, model_type: str) -> bool:
        """指定された種類のモデルをアンロードする"""
        pass
    
    def get_model(self, model_type: str):
        """指定された種類のモデルを取得する"""
        pass
    
    def classify_image(self, image_path: str, model_type: str) -> Dict:
        """画像を分類する"""
        pass
    
    def tag_image(self, image_path: str, model_type: str) -> List[Dict]:
        """画像にタグを付ける"""
        pass
```

## 4. インフラストラクチャ層 (Infrastructure Layer)

インフラストラクチャ層はドメイン層で定義されたインターフェースの実装を提供する。

### 4.1 リポジトリ実装 (Repository Implementations)

#### 4.1.1 SQLiteImageRepository

SQLiteを使用した画像リポジトリの実装。

```python
class SQLiteImageRepository(ImageRepository):
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.connection = sqlite3.connect(db_path)
        self._create_tables_if_not_exist()
    
    def _create_tables_if_not_exist(self):
        """必要なテーブルがなければ作成する"""
        pass
    
    def get_by_id(self, image_id: str) -> Optional[Image]:
        """IDで画像を取得する"""
        pass
    
    def get_by_path(self, path: str) -> Optional[Image]:
        """パスで画像を取得する"""
        pass
    
    def get_images_in_folder(self, folder_path: str, 
                            page: int = 0, page_size: int = 100) -> List[Image]:
        """フォルダ内の画像を取得する"""
        pass
    
    def save(self, image: Image) -> Image:
        """画像を保存する"""
        pass
    
    def delete(self, image_id: str) -> bool:
        """画像を削除する"""
        pass
    
    def search(self, query: str) -> List[Image]:
        """画像を検索する"""
        pass
```

#### 4.1.2 SQLiteClassificationRepository

SQLiteを使用した分類結果リポジトリの実装。

```python
class SQLiteClassificationRepository(ClassificationRepository):
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.connection = sqlite3.connect(db_path)
        self._create_tables_if_not_exist()
    
    def _create_tables_if_not_exist(self):
        """必要なテーブルがなければ作成する"""
        pass
    
    def get_by_image_id(self, image_id: str) -> Optional[ImageClassification]:
        """画像IDで分類結果を取得する"""
        pass
    
    def save(self, classification: ImageClassification) -> ImageClassification:
        """分類結果を保存する"""
        pass
    
    def get_nsfw_images(self, page: int = 0, page_size: int = 100) -> List[str]:
        """NSFW画像のIDリストを取得する"""
        pass
    
    def get_sfw_images(self, page: int = 0, page_size: int = 100) -> List[str]:
        """健全画像のIDリストを取得する"""
        pass
```

#### 4.1.3 SQLiteTagRepository

SQLiteを使用したタグリポジトリの実装。

```python
class SQLiteTagRepository(TagRepository):
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.connection = sqlite3.connect(db_path)
        self._create_tables_if_not_exist()
    
    def _create_tables_if_not_exist(self):
        """必要なテーブルがなければ作成する"""
        pass
    
    def get_by_id(self, tag_id: str) -> Optional[Tag]:
        """IDでタグを取得する"""
        pass
    
    def get_by_name(self, name: str) -> Optional[Tag]:
        """名前でタグを取得する"""
        pass
    
    def save(self, tag: Tag) -> Tag:
        """タグを保存する"""
        pass
    
    def get_tags_for_image(self, image_id: str) -> List[Tag]:
        """画像に付けられたタグを取得する"""
        pass
    
    def add_tag_to_image(self, image_id: str, tag_id: str, 
                        confidence: float) -> bool:
        """画像にタグを付ける"""
        pass
    
    def remove_tag_from_image(self, image_id: str, tag_id: str) -> bool:
        """画像からタグを削除する"""
        pass
```

#### 4.1.4 SQLiteFolderRepository

SQLiteを使用したフォルダリポジトリの実装。

```python
class SQLiteFolderRepository(FolderRepository):
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.connection = sqlite3.connect(db_path)
        self._create_tables_if_not_exist()
    
    def _create_tables_if_not_exist(self):
        """必要なテーブルがなければ作成する"""
        pass
    
    def get_by_id(self, folder_id: str) -> Optional[Folder]:
        """IDでフォルダを取得する"""
        pass
    
    def get_by_path(self, path: str) -> Optional[Folder]:
        """パスでフォルダを取得する"""
        pass
    
    def get_subfolders(self, parent_id: str) -> List[Folder]:
        """親フォルダのサブフォルダを取得する"""
        pass
    
    def save(self, folder: Folder) -> Folder:
        """フォルダを保存する"""
        pass
```

### 4.2 機械学習モデル実装 (ML Model Implementations)

#### 4.2.1 TensorFlowNSFWClassifier

TensorFlowを使用したNSFW分類器の実装。

```python
class TensorFlowNSFWClassifier:
    def __init__(self, model_path: str):
        self.model_path = model_path
        self.model = None
        self.loaded = False
    
    def load(self) -> bool:
        """モデルをロードする"""
        try:
            self.model = tf.keras.models.load_model(self.model_path)
            self.loaded = True
            return True
        except Exception as e:
            print(f"Error loading model: {e}")
            return False
    
    def unload(self) -> bool:
        """モデルをアンロードする"""
        self.model = None
        self.loaded = False
        return True
    
    def predict(self, image_path: str) -> Dict:
        """画像を分類する"""
        if not self.loaded:
            if not self.load():
                raise ValueError("Failed to load model")
        
        # 画像の前処理
        img = self._preprocess_image(image_path)
        
        # 予測実行
        prediction = self.model.predict(img)
        
        # 結果の解釈
        result = self._interpret_prediction(prediction)
        
        return result
    
    def _preprocess_image(self, image_path: str) -> np.ndarray:
        """画像を前処理する"""
        pass
    
    def _interpret_prediction(self, prediction) -> Dict:
        """予測結果を解釈する"""
        pass
```

#### 4.2.2 DanbooruTagger

Danbooruスタイルのタグ付けモデルの実装。

```python
class DanbooruTagger:
    def __init__(self, model_path: str, tag_list_path: str):
        self.model_path = model_path
        self.tag_list_path = tag_list_path
        self.model = None
        self.tag_list = []
        self.loaded = False
    
    def load(self) -> bool:
        """モデルをロードする"""
        try:
            self.model = tf.keras.models.load_model(self.model_path)
            self._load_tag_list()
            self.loaded = True
            return True
        except Exception as e:
            print(f"Error loading model: {e}")
            return False
    
    def _load_tag_list(self):
        """タグリストをロードする"""
        with open(self.tag_list_path, 'r', encoding='utf-8') as f:
            self.tag_list = [line.strip() for line in f if line.strip()]
    
    def unload(self) -> bool:
        """モデルをアンロードする"""
        self.model = None
        self.tag_list = []
        self.loaded = False
        return True
    
    def predict(self, image_path: str, threshold: float = 0.5) -> List[Tuple[str, float]]:
        """画像を分析し、タグと確信度のリストを返す"""
        if not self.loaded:
            if not self.load():
                raise ValueError("Failed to load model")
        
        # 画像の前処理
        img = self._preprocess_image(image_path)
        
        # 予測実行
        predictions = self.model.predict(img)[0]
        
        # 閾値以上の予測結果を返す
        results = []
        for i, prob in enumerate(predictions):
            if prob >= threshold and i < len(self.tag_list):
                results.append((self.tag_list[i], float(prob)))
        
        # 確信度の降順でソート
        results.sort(key=lambda x: x[1], reverse=True)
        
        return results
    
    def _preprocess_image(self, image_path: str) -> np.ndarray:
        """画像を前処理する"""
        pass
```

### 4.3 ファイル操作実装 (File Operation Implementations)

#### 4.3.1 PythonFileSystem

Pythonの標準ライブラリを使用したファイルシステム操作の実装。

```python
class PythonFileSystem:
    def list_directory(self, path: str) -> List[Dict]:
        """ディレクトリ内のファイルとフォルダを一覧表示する"""
        items = []
        for item in os.listdir(path):
            item_path = os.path.join(path, item)
            is_dir = os.path.isdir(item_path)
            if is_dir or self._is_supported_image(item):
                items.append({
                    "name": item,
                    "path": item_path,
                    "is_directory": is_dir,
                    "size": os.path.getsize(item_path) if not is_dir else 0,
                    "modified": datetime.fromtimestamp(os.path.getmtime(item_path))
                })
        return items
    
    def _is_supported_image(self, filename: str) -> bool:
        """サポートされている画像ファイルかどうかを判定する"""
        ext = os.path.splitext(filename)[1].lower()
        return ext in ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.mp4']
    
    def get_image_metadata(self, path: str) -> Dict:
        """画像ファイルのメタデータを取得する"""
        if not os.path.exists(path):
            raise FileNotFoundError(f"File not found: {path}")
        
        ext = os.path.splitext(path)[1].lower()
        if ext == '.mp4':
            return self._get_video_metadata(path)
        else:
            return self._get_image_metadata(path)
    
    def _get_image_metadata(self, path: str) -> Dict:
        """画像ファイルのメタデータを取得する"""
        pass
    
    def _get_video_metadata(self, path: str) -> Dict:
        """動画ファイルのメタデータを取得する"""
        pass
```

## 5. プレゼンテーション層 (Presentation Layer)

プレゼンテーション層はMVVMパターンに基づいて実装される。

### 5.1 ビューモデル (ViewModels)

#### 5.1.1 MainWindowViewModel

メイン画面のビューモデル。

```python
class MainWindowViewModel:
    def __init__(self, browse_folder_use_case: BrowseFolderUseCase,
                view_image_use_case: ViewImageUseCase):
        self.browse_folder_use_case = browse_folder_use_case
        self.view_image_use_case = view_image_use_case
        
        # 状態
        self.current_folder_path = ""
        self.current_images = []
        self.current_subfolders = []
        self.selected_image_id = None
        self.current_page = 0
        self.page_size = 100
        
        # シグナル
        self.on_folder_changed = Signal()
        self.on_image_selected = Signal()
        self.on_images_loaded = Signal()
        self.on_error = Signal()
    
    def load_folder(self, folder_path: str):
        """フォルダを読み込む"""
        try:
            result = self.browse_folder_use_case.execute(
                folder_path, self.current_page, self.page_size
            )
            
            self.current_folder_path = folder_path
            self.current_images = result["images"]
            self.current_subfolders = result["subfolders"]
            
            self.on_folder_changed.emit(folder_path)
            self.on_images_loaded.emit(self.current_images)
        
        except Exception as e:
            self.on_error.emit(str(e))
    
    def select_image(self, image_id: str):
        """画像を選択する"""
        try:
            result = self.view_image_use_case.execute(image_id)
            
            self.selected_image_id = image_id
            self.on_image_selected.emit(result)
        
        except Exception as e:
            self.on_error.emit(str(e))
    
    def next_image(self):
        """次の画像を選択する"""
        if not self.current_images or not self.selected_image_id:
            return
        
        current_index = next(
            (i for i, img in enumerate(self.current_images) 
             if img.id == self.selected_image_id), 
            -1
        )
        
        if current_index >= 0 and current_index < len(self.current_images) - 1:
            next_image = self.current_images[current_index + 1]
            self.select_image(next_image.id)
    
    def previous_image(self):
        """前の画像を選択する"""
        if not self.current_images or not self.selected_image_id:
            return
        
        current_index = next(
            (i for i, img in enumerate(self.current_images) 
             if img.id == self.selected_image_id), 
            -1
        )
        
        if current_index > 0:
            prev_image = self.current_images[current_index - 1]
            self.select_image(prev_image.id)
```

#### 5.1.2 ImageViewModel

画像表示のビューモデル。

```python
class ImageViewModel:
    def __init__(self, view_image_use_case: ViewImageUseCase,
                classify_image_use_case: ClassifyImageUseCase,
                tag_image_use_case: TagImageUseCase):
        self.view_image_use_case = view_image_use_case
        self.classify_image_use_case = classify_image_use_case
        self.tag_image_use_case = tag_image_use_case
        
        # 状態
        self.current_image = None
        self.current_classification = None
        self.current_tags = []
        self.zoom_level = 1.0
        self.rotation = 0
        
        # シグナル
        self.on_image_loaded = Signal()
        self.on_classification_changed = Signal()
        self.on_tags_changed = Signal()
        self.on_error = Signal()
    
    def load_image(self, image_id: str):
        """画像を読み込む"""
        try:
            result = self.view_image_use_case.execute(image_id)
            
            self.current_image = result["image"]
            self.current_classification = result["classification"]
            self.current_tags = result["tags"]
            self.zoom_level = 1.0
            self.rotation = 0
            
            self.on_image_loaded.emit(self.current_image)
            if self.current_classification:
                self.on_classification_changed.emit(self.current_classification)
            if self.current_tags:
                self.on_tags_changed.emit(self.current_tags)
        
        except Exception as e:
            self.on_error.emit(str(e))
    
    def classify_image(self, classifier_type: str = "default"):
        """画像を分類する"""
        if not self.current_image:
            return
        
        try:
            self.current_classification = self.classify_image_use_case.execute(
                self.current_image.id, classifier_type
            )
            self.on_classification_changed.emit(self.current_classification)
        
        except Exception as e:
            self.on_error.emit(str(e))
    
    def tag_image(self, tagger_type: str = "danbooru"):
        """画像にタグを付ける"""
        if not self.current_image:
            return
        
        try:
            result = self.tag_image_use_case.execute(
                self.current_image.id, tagger_type
            )
            
            # タグ情報を更新
            tags = [item["tag"] for item in result]
            self.current_tags = tags
            
            self.on_tags_changed.emit(self.current_tags)
        
        except Exception as e:
            self.on_error.emit(str(e))
    
    def zoom_in(self):
        """ズームイン"""
        self.zoom_level = min(self.zoom_level * 1.2, 5.0)
        self.on_image_loaded.emit(self.current_image)  # 再描画
    
    def zoom_out(self):
        """ズームアウト"""
        self.zoom_level = max(self.zoom_level / 1.2, 0.1)
        self.on_image_loaded.emit(self.current_image)  # 再描画
    
    def rotate_clockwise(self):
        """時計回りに回転"""
        self.rotation = (self.rotation + 90) % 360
        self.on_image_loaded.emit(self.current_image)  # 再描画
    
    def rotate_counterclockwise(self):
        """反時計回りに回転"""
        self.rotation = (self.rotation - 90) % 360
        self.on_image_loaded.emit(self.current_image)  # 再描画
```

#### 5.1.3 ClassificationViewModel

分類機能のビューモデル。

```python
class ClassificationViewModel:
    def __init__(self, batch_classify_images_use_case: BatchClassifyImagesUseCase):
        self.batch_classify_images_use_case = batch_classify_images_use_case
        
        # 状態
        self.current_folder_path = ""
        self.classification_progress = 0
        self.classification_total = 0
        self.classification_is_running = False
        
        # シグナル
        self.on_classification_started = Signal()
        self.on_classification_progress = Signal()
        self.on_classification_completed = Signal()
        self.on_error = Signal()
    
    def classify_folder(self, folder_path: str, 
                       apply_nsfw: bool = True, 
                       apply_tags: bool = True):
        """フォルダ内の画像を分類する"""
        if self.classification_is_running:
            return
        
        self.classification_is_running = True
        self.current_folder_path = folder_path
        self.classification_progress = 0
        
        try:
            self.on_classification_started.emit(folder_path)
            
            # 非同期処理として実行すべきだが、簡略化のため同期処理で記述
            result = self.batch_classify_images_use_case.execute(
                folder_path, apply_nsfw, apply_tags
            )
            
            self.classification_total = result["total"]
            self.classification_progress = result["total"]
            
            self.on_classification_completed.emit(result)
        
        except Exception as e:
            self.on_error.emit(str(e))
        
        finally:
            self.classification_is_running = False
```

### 5.2 ビュー (Views)

#### 5.2.1 MainWindow

アプリケーションのメインウィンドウ。

```python
class MainWindow(QMainWindow):
    def __init__(self, main_view_model: MainWindowViewModel,
                image_view_model: ImageViewModel,
                classification_view_model: ClassificationViewModel):
        super().__init__()
        
        self.main_view_model = main_view_model
        self.image_view_model = image_view_model
        self.classification_view_model = classification_view_model
        
        self.setWindowTitle("画像ビューワー")
        self.resize(1200, 800)
        
        self._setup_ui()
        self._connect_signals()
    
    def _setup_ui(self):
        """UIのセットアップ"""
        # ウィジェットの作成
        self.folder_tree = FolderTreeWidget()
        self.image_list = ImageListWidget()
        self.image_view = ImageViewWidget()
        self.tag_panel = TagPanelWidget()
        
        # メニューバーのセットアップ
        self._setup_menu_bar()
        
        # ツールバーのセットアップ
        self._setup_tool_bar()
        
        # レイアウトのセットアップ
        main_layout = QHBoxLayout()
        
        # 左側（フォルダツリーとイメージリスト）
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.addWidget(self.folder_tree)
        left_layout.addWidget(self.image_list)
        
        # 右側（画像ビューとタグパネル）
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.addWidget(self.image_view, 3)
        right_layout.addWidget(self.tag_panel, 1)
        
        # スプリッターの設定
        splitter = QSplitter(Qt.Horizontal)
        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        splitter.setSizes([300, 900])
        
        # 中央ウィジェットの設定
        central_widget = QWidget()
        central_widget.setLayout(QVBoxLayout())
        central_widget.layout().addWidget(splitter)
        self.setCentralWidget(central_widget)
    
    def _setup_menu_bar(self):
        """メニューバーのセットアップ"""
        menubar = self.menuBar()
        
        # ファイルメニュー
        file_menu = menubar.addMenu("ファイル")
        
        open_folder_action = QAction("フォルダを開く", self)
        open_folder_action.triggered.connect(self._open_folder_dialog)
        file_menu.addAction(open_folder_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction("終了", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # 表示メニュー
        view_menu = menubar.addMenu("表示")
        
        zoom_in_action = QAction("拡大", self)
        zoom_in_action.triggered.connect(self.image_view_model.zoom_in)
        view_menu.addAction(zoom_in_action)
        
        zoom_out_action = QAction("縮小", self)
        zoom_out_action.triggered.connect(self.image_view_model.zoom_out)
        view_menu.addAction(zoom_out_action)
        
        view_menu.addSeparator()
        
        rotate_cw_action = QAction("時計回りに回転", self)
        rotate_cw_action.triggered.connect(self.image_view_model.rotate_clockwise)
        view_menu.addAction(rotate_cw_action)
        
        rotate_ccw_action = QAction("反時計回りに回転", self)
        rotate_ccw_action.triggered.connect(self.image_view_model.rotate_counterclockwise)
        view_menu.addAction(rotate_ccw_action)
        
        # 分類メニュー
        classify_menu = menubar.addMenu("分類")
        
        classify_current_action = QAction("現在の画像を分類", self)
        classify_current_action.triggered.connect(
            lambda: self.image_view_model.classify_image()
        )
        classify_menu.addAction(classify_current_action)
        
        tag_current_action = QAction("現在の画像にタグ付け", self)
        tag_current_action.triggered.connect(
            lambda: self.image_view_model.tag_image()
        )
        classify_menu.addAction(tag_current_action)
        
        classify_menu.addSeparator()
        
        classify_folder_action = QAction("フォルダ内の画像を一括分類", self)
        classify_folder_action.triggered.connect(self._classify_current_folder)
        classify_menu.addAction(classify_folder_action)
    
    def _setup_tool_bar(self):
        """ツールバーのセットアップ"""
        toolbar = self.addToolBar("メインツールバー")
        
        # 前の画像
        prev_action = QAction(QIcon.fromTheme("go-previous"), "前の画像", self)
        prev_action.triggered.connect(self.main_view_model.previous_image)
        toolbar.addAction(prev_action)
        
        # 次の画像
        next_action = QAction(QIcon.fromTheme("go-next"), "次の画像", self)
        next_action.triggered.connect(self.main_view_model.next_image)
        toolbar.addAction(next_action)
        
        toolbar.addSeparator()
        
        # ズームイン
        zoom_in_action = QAction(QIcon.fromTheme("zoom-in"), "拡大", self)
        zoom_in_action.triggered.connect(self.image_view_model.zoom_in)
        toolbar.addAction(zoom_in_action)
        
        # ズームアウト
        zoom_out_action = QAction(QIcon.fromTheme("zoom-out"), "縮小", self)
        zoom_out_action.triggered.connect(self.image_view_model.zoom_out)
        toolbar.addAction(zoom_out_action)
        
        toolbar.addSeparator()
        
        # 回転
        rotate_cw_action = QAction(QIcon.fromTheme("object-rotate-right"), "時計回りに回転", self)
        rotate_cw_action.triggered.connect(self.image_view_model.rotate_clockwise)
        toolbar.addAction(rotate_cw_action)
        
        rotate_ccw_action = QAction(QIcon.fromTheme("object-rotate-left"), "反時計回りに回転", self)
        rotate_ccw_action.triggered.connect(self.image_view_model.rotate_counterclockwise)
        toolbar.addAction(rotate_ccw_action)
    
    def _connect_signals(self):
        """シグナルの接続"""
        # フォルダツリーのシグナル
        self.folder_tree.folder_selected.connect(self.main_view_model.load_folder)
        
        # イメージリストのシグナル
        self.image_list.image_selected.connect(self.main_view_model.select_image)
        
        # メインビューモデルのシグナル
        self.main_view_model.on_folder_changed.connect(self._update_folder_path)
        self.main_view_model.on_images_loaded.connect(self.image_list.set_images)
        self.main_view_model.on_image_selected.connect(self._handle_image_selected)
        self.main_view_model.on_error.connect(self._show_error)
        
        # 画像ビューモデルのシグナル
        self.image_view_model.on_image_loaded.connect(self.image_view.set_image)
        self.image_view_model.on_classification_changed.connect(self._update_classification)
        self.image_view_model.on_tags_changed.connect(self.tag_panel.set_tags)
        self.image_view_model.on_error.connect(self._show_error)
        
        # 分類ビューモデルのシグナル
        self.classification_view_model.on_classification_started.connect(self._classification_started)
        self.classification_view_model.on_classification_progress.connect(self._classification_progress)
        self.classification_view_model.on_classification_completed.connect(self._classification_completed)
        self.classification_view_model.on_error.connect(self._show_error)
    
    def _open_folder_dialog(self):
        """フォルダ選択ダイアログを開く"""
        folder_path = QFileDialog.getExistingDirectory(
            self, "フォルダを開く", "", QFileDialog.ShowDirsOnly
        )
        if folder_path:
            self.main_view_model.load_folder(folder_path)
    
    def _classify_current_folder(self):
        """現在のフォルダ内の画像を分類する"""
        if not self.main_view_model.current_folder_path:
            self._show_error("フォルダが選択されていません")
            return
        
        dialog = ClassificationDialog(self)
        if dialog.exec_() == QDialog.Accepted:
            self.classification_view_model.classify_folder(
                self.main_view_model.current_folder_path,
                dialog.apply_nsfw,
                dialog.apply_tags
            )
    
    def _update_folder_path(self, folder_path: str):
        """フォルダパスを更新する"""
        self.setWindowTitle(f"画像ビューワー - {folder_path}")
    
    def _handle_image_selected(self, result: Dict):
        """画像が選択されたときの処理"""
        self.image_view_model.load_image(result["image"].id)
    
    def _update_classification(self, classification: ImageClassification):
        """分類結果を更新する"""
        is_nsfw = classification.is_nsfw
        nsfw_score = classification.nsfw_score
        
        status_bar_msg = f"NSFW: {'はい' if is_nsfw else 'いいえ'} (スコア: {nsfw_score:.2f})"
        self.statusBar().showMessage(status_bar_msg)
    
    def _classification_started(self, folder_path: str):
        """分類開始時の処理"""
        self.statusBar().showMessage(f"分類中: {folder_path}")
    
    def _classification_progress(self, progress: int, total: int):
        """分類進捗時の処理"""
        self.statusBar().showMessage(f"分類中: {progress}/{total}")
    
    def _classification_completed(self, result: Dict):
        """分類完了時の処理"""
        msg = (f"分類完了: {result['total']}枚中 "
               f"{result['nsfw_classified']}枚NSFW分類, "
               f"{result['tagged']}枚タグ付け")
        self.statusBar().showMessage(msg)
        
        QMessageBox.information(self, "分類完了", msg)
    
    def _show_error(self, error_msg: str):
        """エラーメッセージを表示する"""
        QMessageBox.critical(self, "エラー", error_msg)
```

### 5.3 カスタムウィジェット (Custom Widgets)

#### 5.3.1 FolderTreeWidget

フォルダツリーを表示するウィジェット。

```python
class FolderTreeWidget(QTreeView):
    folder_selected = Signal(str)
    
    def __init__(self):
        super().__init__()
        
        self.setHeaderHidden(True)
        
        # ファイルシステムモデルの設定
        self.model = QFileSystemModel()
        self.model.setFilter(QDir.AllDirs | QDir.NoDotAndDotDot)
        self.model.setRootPath(QDir.rootPath())
        
        self.setModel(self.model)
        
        # ルートインデックスの設定
        self.setRootIndex(self.model.index(QDir.homePath()))
        
        # 選択モードの設定
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        
        # シグナルの接続
        self.clicked.connect(self._on_folder_clicked)
    
    def _on_folder_clicked(self, index):
        """フォルダがクリックされたときの処理"""
        path = self.model.filePath(index)
        self.folder_selected.emit(path)
```

#### 5.3.2 ImageListWidget

画像のサムネイルリストを表示するウィジェット。

```python
class ImageListWidget(QListWidget):
    image_selected = Signal(str)
    
    def __init__(self):
        super().__init__()
        
        self.setViewMode(QListView.IconMode)
        self.setIconSize(QSize(120, 120))
        self.setResizeMode(QListView.Adjust)
        self.setWrapping(True)
        self.setSpacing(10)
        
        # シグナルの接続
        self.itemClicked.connect(self._on_item_clicked)
    
    def set_images(self, images: List[Image]):
        """画像リストを設定する"""
        self.clear()
        
        for image in images:
            item = QListWidgetItem()
            item.setText(image.filename)
            item.setData(Qt.UserRole, image.id)
            
            # サムネイルの設定（実際には非同期で行うべき）
            pixmap = QPixmap(image.path)
            if not pixmap.isNull():
                pixmap = pixmap.scaled(120, 120, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                item.setIcon(QIcon(pixmap))
            else:
                # 画像が読み込めない場合のデフォルトアイコン
                item.setIcon(QIcon.fromTheme("image-x-generic"))
            
            self.addItem(item)
    
    def _on_item_clicked(self, item):
        """アイテムがクリックされたときの処理"""
        image_id = item.data(Qt.UserRole)
        self.image_selected.emit(image_id)
```

#### 5.3.3 ImageViewWidget

画像を表示するウィジェット。

```python
class ImageViewWidget(QScrollArea):
    def __init__(self):
        super().__init__()
        
        self.setWidgetResizable(True)
        self.setAlignment(Qt.AlignCenter)
        
        # 画像表示用ラベル
        self.image_label = QLabel()
        self.image_label.setAlignment(Qt.AlignCenter)
        self.image_label.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)
        
        self.setWidget(self.image_label)
        
        # 画像データ
        self.current_pixmap = None
        self.zoom_level = 1.0
        self.rotation = 0
    
    def set_image(self, image: Image):
        """画像を設定する"""
        pixmap = QPixmap(image.path)
        if pixmap.isNull():
            self.image_label.setText("画像を読み込めませんでした")
            return
        
        self.current_pixmap = pixmap
        self._update_display()
    
    def set_zoom(self, zoom_level: float):
        """ズームレベルを設定する"""
        self.zoom_level = zoom_level
        self._update_display()
    
    def set_rotation(self, rotation: int):
        """回転角度を設定する"""
        self.rotation = rotation
        self._update_display()
    
    def _update_display(self):
        """表示を更新する"""
        if self.current_pixmap is None:
            return
        
        # 回転
        transform = QTransform().rotate(self.rotation)
        rotated_pixmap = self.current_pixmap.transformed(transform)
        
        # ズーム
        w = int(rotated_pixmap.width() * self.zoom_level)
        h = int(rotated_pixmap.height() * self.zoom_level)
        
        # 表示
        self.image_label.setPixmap(
            rotated_pixmap.scaled(w, h, Qt.KeepAspectRatio, Qt.SmoothTransformation)
        )
        
        # ラベルのサイズを調整
        self.image_label.resize(w, h)
```

#### 5.3.4 TagPanelWidget

タグ情報を表示するウィジェット。

```python
class TagPanelWidget(QWidget):
    def __init__(self):
        super().__init__()
        
        layout = QVBoxLayout(self)
        
        # ヘッダー
        header_label = QLabel("タグ")
        header_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        layout.addWidget(header_label)
        
        # タグリスト
        self.tag_list = QListWidget()
        layout.addWidget(self.tag_list)
    
    def set_tags(self, tags: List[Tag]):
        """タグリストを設定する"""
        self.tag_list.clear()
        
        # カテゴリごとにグループ化
        category_tags = {}
        for tag in tags:
            if tag.category not in category_tags:
                category_tags[tag.category] = []
            category_tags[tag.category].append(tag)
        
        # カテゴリごとに表示
        for category, tags in category_tags.items():
            category_item = QListWidgetItem(f"【{category}】")
            category_item.setBackground(QColor(240, 240, 240))
            category_item.setFlags(Qt.NoItemFlags)  # 選択不可
            self.tag_list.addItem(category_item)
            
            for tag in tags:
                tag_item = QListWidgetItem(f"    {tag.name}")
                self.tag_list.addItem(tag_item)
```

#### 5.3.5 ClassificationDialog

分類設定ダイアログ。

```python
class ClassificationDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        
        self.setWindowTitle("分類設定")
        
        layout = QVBoxLayout(self)
        
        # NSFW分類のチェックボックス
        self.nsfw_check = QCheckBox("NSFW分類を実行")
        self.nsfw_check.setChecked(True)
        layout.addWidget(self.nsfw_check)
        
        # タグ付けのチェックボックス
        self.tag_check = QCheckBox("タグ付けを実行")
        self.tag_check.setChecked(True)
        layout.addWidget(self.tag_check)
        
        # ボタン
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
    
    @property
    def apply_nsfw(self) -> bool:
        """NSFW分類を適用するかどうか"""
        return self.nsfw_check.isChecked()
    
    @property
    def apply_tags(self) -> bool:
        """タグ付けを適用するかどうか"""
        return self.tag_check.isChecked()
```

## 6. アプリケーション初期化

### 6.1 依存性注入の設定

```python
def setup_application():
    """アプリケーションの依存性注入を設定する"""
    # データベースパス
    db_path = os.path.join(
        os.path.expanduser("~"), ".image_viewer", "data.db"
    )
    os.makedirs(os.path.dirname(db_path), exist_ok=True)
    
    # リポジトリの作成
    image_repository = SQLiteImageRepository(db_path)
    classification_repository = SQLiteClassificationRepository(db_path)
    tag_repository = SQLiteTagRepository(db_path)
    folder_repository = SQLiteFolderRepository(db_path)
    
    # サービスの作成
    file_system_service = FileSystemService()
    classification_model_service = ClassificationModelService()
    
    # ドメインサービスの作成
    classification_service = ImageClassificationService(
        classification_model_service
    )
    
    # ユースケースの作成
    view_image_use_case = ViewImageUseCase(
        image_repository, classification_repository, tag_repository
    )
    
    browse_folder_use_case = BrowseFolderUseCase(
        folder_repository, image_repository
    )
    
    classify_image_use_case = ClassifyImageUseCase(
        image_repository, classification_repository, classification_service
    )
    
    tag_image_use_case = TagImageUseCase(
        image_repository, tag_repository, classification_service
    )
    
    batch_classify_images_use_case = BatchClassifyImagesUseCase(
        image_repository, classification_repository, tag_repository,
        classification_service
    )
    
    # ビューモデルの作成
    main_view_model = MainWindowViewModel(
        browse_folder_use_case, view_image_use_case
    )
    
    image_view_model = ImageViewModel(
        view_image_use_case, classify_image_use_case, tag_image_use_case
    )
    
    classification_view_model = ClassificationViewModel(
        batch_classify_images_use_case
    )
    
    # メインウィンドウの作成
    main_window = MainWindow(
        main_view_model, image_view_model, classification_view_model
    )
    
    return main_window
```

### 6.2 アプリケーションのエントリーポイント

```python
def main():
    """アプリケーションのエントリーポイント"""
    app = QApplication(sys.argv)
    
    # アプリケーション情報の設定
    app.setApplicationName("画像ビューワー")
    app.setApplicationVersion("1.0.0")
    app.setOrganizationName("Your Organization")
    
    # スタイルシートの適用
    app.setStyle("Fusion")
    
    # メインウィンドウの作成と表示
    main_window = setup_application()
    main_window.show()
    
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
```

この詳細設計書では、クリーンアーキテクチャとMVVMパターンに基づいて、画像ビューワーアプリケーションの各レイヤーとコンポーネントを定義しています。各レイヤーはそれぞれの責務を持ち、互いに疎結合に保たれています。これにより、アプリケーションの保守性と拡張性が高まります。
